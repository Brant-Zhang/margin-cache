!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Append	solo.go	/^func (client *Client) Append(key string, val []byte) error {$/;"	f
Auth	solo.go	/^func (client *Client) Auth(password string) error {$/;"	f
Blpop	solo.go	/^func (client *Client) Blpop(keys []string, timeoutSecs uint) (*string, []byte, error) {$/;"	f
Brpop	solo.go	/^func (client *Client) Brpop(keys []string, timeoutSecs uint) (*string, []byte, error) {$/;"	f
Client	solo.go	/^type Client struct {$/;"	t
Dbsize	solo.go	/^func (client *Client) Dbsize() (int, error) {$/;"	f
Decr	solo.go	/^func (client *Client) Decr(key string) (int64, error) {$/;"	f
Decrby	solo.go	/^func (client *Client) Decrby(key string, val int64) (int64, error) {$/;"	f
Del	solo.go	/^func (client *Client) Del(key string) (bool, error) {$/;"	f
Error	solo.go	/^func (err fusionError) Error() string { return "fusion Error: " + string(err) }$/;"	f
Exists	solo.go	/^func (client *Client) Exists(key string) (bool, error) {$/;"	f
Expire	solo.go	/^func (client *Client) Expire(key string, time int64) (bool, error) {$/;"	f
Flush	solo.go	/^func (client *Client) Flush(all bool) error {$/;"	f
Get	solo.go	/^func (client *Client) Get(key string) ([]byte, error) {$/;"	f
Getset	solo.go	/^func (client *Client) Getset(key string, val []byte) ([]byte, error) {$/;"	f
Hdel	solo.go	/^func (client *Client) Hdel(key string, field string) (bool, error) {$/;"	f
Hexists	solo.go	/^func (client *Client) Hexists(key string, field string) (bool, error) {$/;"	f
Hget	solo.go	/^func (client *Client) Hget(key string, field string) ([]byte, error) {$/;"	f
Hgetall	solo.go	/^func (client *Client) Hgetall(key string, val interface{}) error {$/;"	f
Hincrby	solo.go	/^func (client *Client) Hincrby(key string, field string, val int64) (int64, error) {$/;"	f
Hkeys	solo.go	/^func (client *Client) Hkeys(key string) ([]string, error) {$/;"	f
Hlen	solo.go	/^func (client *Client) Hlen(key string) (int, error) {$/;"	f
Hmget	solo.go	/^func (client *Client) Hmget(key string, fields ...string) ([][]byte, error) {$/;"	f
Hmset	solo.go	/^func (client *Client) Hmset(key string, mapping interface{}) error {$/;"	f
Hset	solo.go	/^func (client *Client) Hset(key string, field string, val []byte) (bool, error) {$/;"	f
Hsetex	solo.go	/^func (client *Client) Hsetex(key string, field string, ex int, val []byte) (bool, error) {$/;"	f
Hvals	solo.go	/^func (client *Client) Hvals(key string) ([][]byte, error) {$/;"	f
Incr	solo.go	/^func (client *Client) Incr(key string) (int64, error) {$/;"	f
Incrby	solo.go	/^func (client *Client) Incrby(key string, val int64) (int64, error) {$/;"	f
Keys	solo.go	/^func (client *Client) Keys(pattern string) ([]string, error) {$/;"	f
Lindex	solo.go	/^func (client *Client) Lindex(key string, index int) ([]byte, error) {$/;"	f
Llen	solo.go	/^func (client *Client) Llen(key string) (int, error) {$/;"	f
Lpop	solo.go	/^func (client *Client) Lpop(key string) ([]byte, error) {$/;"	f
Lpush	solo.go	/^func (client *Client) Lpush(key string, val []byte) error {$/;"	f
Lrange	solo.go	/^func (client *Client) Lrange(key string, start int, end int) ([][]byte, error) {$/;"	f
Lrem	solo.go	/^func (client *Client) Lrem(key string, count int, value []byte) (int, error) {$/;"	f
Lset	solo.go	/^func (client *Client) Lset(key string, index int, value []byte) error {$/;"	f
Ltrim	solo.go	/^func (client *Client) Ltrim(key string, start int, end int) error {$/;"	f
Mget	solo.go	/^func (client *Client) Mget(keys ...string) ([][]byte, error) {$/;"	f
Move	solo.go	/^func (client *Client) Move(key string, dbnum int) (bool, error) {$/;"	f
Mset	solo.go	/^func (client *Client) Mset(mapping map[string][]byte) error {$/;"	f
Msetnx	solo.go	/^func (client *Client) Msetnx(mapping map[string][]byte) (bool, error) {$/;"	f
Ping	solo.go	/^func (client *Client) Ping() (int64, error) {$/;"	f
Randomkey	solo.go	/^func (client *Client) Randomkey() (string, error) {$/;"	f
Rename	solo.go	/^func (client *Client) Rename(src string, dst string) error {$/;"	f
Renamenx	solo.go	/^func (client *Client) Renamenx(src string, dst string) (bool, error) {$/;"	f
Rpop	solo.go	/^func (client *Client) Rpop(key string) ([]byte, error) {$/;"	f
Rpoplpush	solo.go	/^func (client *Client) Rpoplpush(src string, dst string) ([]byte, error) {$/;"	f
Rpush	solo.go	/^func (client *Client) Rpush(key string, val []byte) error {$/;"	f
Sadd	solo.go	/^func (client *Client) Sadd(key string, value []byte) (bool, error) {$/;"	f
Scard	solo.go	/^func (client *Client) Scard(key string) (int, error) {$/;"	f
Sdiff	solo.go	/^func (client *Client) Sdiff(key1 string, keys []string) ([][]byte, error) {$/;"	f
Sdiffstore	solo.go	/^func (client *Client) Sdiffstore(dst string, key1 string, keys []string) (int, error) {$/;"	f
Set	solo.go	/^func (client *Client) Set(key string, val []byte) error {$/;"	f
Setex	solo.go	/^func (client *Client) Setex(key string, time int64, val []byte) error {$/;"	f
Setnx	solo.go	/^func (client *Client) Setnx(key string, val []byte) (bool, error) {$/;"	f
Sinter	solo.go	/^func (client *Client) Sinter(keys ...string) ([][]byte, error) {$/;"	f
Sinterstore	solo.go	/^func (client *Client) Sinterstore(dst string, keys ...string) (int, error) {$/;"	f
Sismember	solo.go	/^func (client *Client) Sismember(key string, value []byte) (bool, error) {$/;"	f
SliceHeader	main.go	/^type SliceHeader struct {$/;"	t
Smembers	solo.go	/^func (client *Client) Smembers(key string) ([][]byte, error) {$/;"	f
Smove	solo.go	/^func (client *Client) Smove(src string, dst string, val []byte) (bool, error) {$/;"	f
Spop	solo.go	/^func (client *Client) Spop(key string) ([]byte, error) {$/;"	f
Srandmember	solo.go	/^func (client *Client) Srandmember(key string) ([]byte, error) {$/;"	f
Srem	solo.go	/^func (client *Client) Srem(key string, value []byte) (bool, error) {$/;"	f
Strlen	solo.go	/^func (client *Client) Strlen(key string) (int, error) {$/;"	f
Substr	solo.go	/^func (client *Client) Substr(key string, start int, end int) ([]byte, error) {$/;"	f
Sunion	solo.go	/^func (client *Client) Sunion(keys ...string) ([][]byte, error) {$/;"	f
Sunionstore	solo.go	/^func (client *Client) Sunionstore(dst string, keys ...string) (int, error) {$/;"	f
Ttl	solo.go	/^func (client *Client) Ttl(key string) (int64, error) {$/;"	f
Type	solo.go	/^func (client *Client) Type(key string) (string, error) {$/;"	f
allkeys	main.go	/^func allkeys() {$/;"	f
bpop	solo.go	/^func (client *Client) bpop(cmd string, keys []string, timeoutSecs uint) (*string, []byte, error) {$/;"	f
client	main.go	/^var client Client$/;"	v
commandBytes	solo.go	/^func commandBytes(cmd string, args ...string) []byte {$/;"	f
containerToString	solo.go	/^func containerToString(val reflect.Value, args *[]string) error {$/;"	f
data	main.go	/^type data struct {$/;"	t
defaultAddr	solo.go	/^var defaultAddr = "127.0.0.1:6380"$/;"	v
defaultPoolSize	solo.go	/^const ($/;"	c
del	main.go	/^func del() {$/;"	f
doesNotExist	solo.go	/^var doesNotExist = fusionError("Key does not exist ")$/;"	v
downCount	main.go	/^var downCount int32 = 0$/;"	v
exists	main.go	/^func exists() {$/;"	f
function	main.go	/^func function() {$/;"	f
fusionError	solo.go	/^type fusionError string$/;"	t
get	main.go	/^func get() {$/;"	f
getBench	main.go	/^func getBench() {$/;"	f
getBenchChild	main.go	/^func getBenchChild(i int, rec int, wg *sync.WaitGroup) {$/;"	f
hdel	main.go	/^func hdel() {$/;"	f
hget	main.go	/^func hget() {$/;"	f
hgetBench	main.go	/^func hgetBench() {$/;"	f
hgetall	main.go	/^func hgetall() {$/;"	f
hmget	main.go	/^func hmget() {$/;"	f
hmset	main.go	/^func hmset() {$/;"	f
hset	main.go	/^func hset() {$/;"	f
hsetBench	main.go	/^func hsetBench(step, count int) {$/;"	f
init	main.go	/^func init() {$/;"	f
main	main.go	/^func main() {$/;"	f
main	main.go	/^package main$/;"	p
main	solo.go	/^package main$/;"	p
openConnection	solo.go	/^func (client *Client) openConnection() (c net.Conn, err error) {$/;"	f
popCon	solo.go	/^func (client *Client) popCon() (net.Conn, error) {$/;"	f
pushCon	solo.go	/^func (client *Client) pushCon(c net.Conn) {$/;"	f
rawSend	solo.go	/^func (client *Client) rawSend(c net.Conn, cmd []byte) (interface{}, error) {$/;"	f
readBulk	solo.go	/^func readBulk(reader *bufio.Reader, head string) ([]byte, error) {$/;"	f
readResponse	solo.go	/^func readResponse(reader *bufio.Reader) (interface{}, error) {$/;"	f
recycle	main.go	/^var recycle int = 10000000$/;"	v
sendCommand	solo.go	/^func (client *Client) sendCommand(cmd string, args ...string) (data interface{}, err error) {$/;"	f
sendCommands	solo.go	/^func (client *Client) sendCommands(cmdArgs <-chan []string, data chan<- interface{}) (err error) {$/;"	f
set	main.go	/^func set() {$/;"	f
setBench	main.go	/^func setBench() {$/;"	f
setBenchChild	main.go	/^func setBenchChild(i int, rec int, wg *sync.WaitGroup, value []byte) {$/;"	f
setget	main.go	/^func setget() {$/;"	f
valueToString	solo.go	/^func valueToString(v reflect.Value) (string, error) {$/;"	f
writeRequest	solo.go	/^func writeRequest(writer io.Writer, cmd string, args ...string) error {$/;"	f
writeTo	solo.go	/^func writeTo(data []byte, val reflect.Value) error {$/;"	f
writeToContainer	solo.go	/^func writeToContainer(data [][]byte, val reflect.Value) error {$/;"	f
